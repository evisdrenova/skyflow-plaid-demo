"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _Client_metaData;
Object.defineProperty(exports, "__esModule", { value: true });
const SkyflowError_1 = __importDefault(require("../libs/SkyflowError"));
const constants_1 = __importDefault(require("../utils/constants"));
const logs_1 = __importDefault(require("../utils/logs"));
const xmlhttprequest_ts_1 = require("xmlhttprequest-ts");
class Client {
    constructor(config, metadata) {
        _Client_metaData.set(this, void 0);
        this.request = (request) => new Promise((resolve, reject) => {
            const httpRequest = new xmlhttprequest_ts_1.XMLHttpRequest();
            if (!httpRequest) {
                reject(new SkyflowError_1.default(constants_1.default.CONNECTION_ERROR, [], true));
                return;
            }
            httpRequest.open(request.requestMethod, request.url);
            if (request.headers) {
                const { headers } = request;
                Object.keys(request.headers).forEach((key) => {
                    httpRequest.setRequestHeader(key, headers[key]);
                });
            }
            httpRequest.send(JSON.stringify(Object.assign({}, request.body)));
            httpRequest.onload = () => {
                var _a, _b;
                const responseHeaders = httpRequest.getAllResponseHeaders();
                const headersList = responseHeaders.trim().split(/[\r\n]+/);
                const headerMap = {};
                headersList.forEach((line) => {
                    const parts = line.split(': ');
                    const header = parts.shift() || '';
                    const value = parts.join(': ');
                    headerMap[header] = value;
                });
                const contentType = headerMap['content-type'];
                if (httpRequest.status < 200 || httpRequest.status >= 400) {
                    if (contentType.includes('application/json')) {
                        reject(new SkyflowError_1.default({
                            code: httpRequest.status,
                            description: (_b = (_a = JSON.parse(httpRequest.responseText)) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.message,
                        }, [], true));
                    }
                    else if (contentType.includes('text/plain')) {
                        reject(new SkyflowError_1.default({
                            code: httpRequest.status,
                            description: httpRequest.responseText,
                        }, [], true));
                    }
                    else {
                        reject(new SkyflowError_1.default({
                            code: httpRequest.status,
                            description: logs_1.default.errorLogs.ERROR_OCCURED,
                        }, [], true));
                    }
                }
                if (contentType.includes('application/json')) {
                    resolve(JSON.parse(httpRequest.responseText));
                }
                resolve(httpRequest.responseText);
            };
            httpRequest.onerror = () => {
                reject(new SkyflowError_1.default(constants_1.default.TRANSACTION_ERROR, [], true));
            };
        });
        this.config = config;
        __classPrivateFieldSet(this, _Client_metaData, metadata, "f");
    }
    toJSON() {
        return {
            config: this.config,
            metaData: __classPrivateFieldGet(this, _Client_metaData, "f"),
        };
    }
    static fromJSON(json) {
        return new Client(json.config, json.metadata);
    }
}
_Client_metaData = new WeakMap();
exports.default = Client;
//# sourceMappingURL=index.js.map