"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const axios_1 = __importDefault(require("axios"));
const jsonwebtoken_1 = __importDefault(require("jsonwebtoken"));
const Messages_1 = require("../errors/Messages");
function GenerateToken(credentialsFilePath) {
    return new Promise((resolve, reject) => {
        let credentials;
        if (!fs_1.default.existsSync(credentialsFilePath)) {
            reject(Messages_1.errorMessages.fileNotFound);
        }
        credentials = fs_1.default.readFileSync(credentialsFilePath, "utf8");
        if (credentials === '')
            reject(Messages_1.errorMessages.EmptyFile);
        try {
            JSON.parse(credentials);
        }
        catch (e) {
            reject(Messages_1.errorMessages.notAValidJSON);
        }
        const credentialsObj = JSON.parse(credentials);
        const expiryTime = Math.floor(Date.now() / 1000) + 60;
        const claims = {
            iss: credentialsObj.clientID,
            key: credentialsObj.keyID,
            aud: credentialsObj.tokenURI,
            exp: expiryTime,
            sub: credentialsObj.clientID,
        };
        if (claims.iss == null) {
            reject(Messages_1.errorMessages.clientIDNotFound);
        }
        if (claims.key == null) {
            reject(Messages_1.errorMessages.keyIDNotFound);
        }
        if (claims.aud == null) {
            reject(Messages_1.errorMessages.tokenURINotFound);
        }
        if (credentialsObj.privateKey == null) {
            reject(Messages_1.errorMessages.privateKeyNotFound);
        }
        const privateKey = credentialsObj.privateKey.toString("utf8");
        const signedJwt = jsonwebtoken_1.default.sign(claims, privateKey, { algorithm: "RS256" });
        (0, axios_1.default)(`${credentialsObj.tokenURI}`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            data: {
                grant_type: "urn:ietf:params:oauth:grant-type:jwt-bearer",
                assertion: signedJwt,
            },
        })
            .then((res) => {
            resolve({
                accessToken: res.data.accessToken,
                tokenType: res.data.tokenType,
            });
        })
            .catch((err) => {
            reject(err);
        });
    });
}
exports.default = GenerateToken;
//# sourceMappingURL=Token.js.map